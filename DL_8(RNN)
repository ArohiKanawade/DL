
import numpy as np
def sigmoid(x):
    return 1 / (1 + np.exp(-x))
X = np.array([[0], [1], [2], [3], [4]], dtype=float)
y = np.array([[1], [2], [3], [4], [5]], dtype=float)
X = X / np.max(X)
y = y / np.max(y)
Wxh = np.random.rand(1, 1)  # input to hidden
Whh = np.random.rand(1, 1)  # hidden to hidden
Why = np.random.rand(1, 1)  # hidden to output
hidden_state = 0
lr = 0.1  # learning rate
for epoch in range(3000):
    for i in range(len(X)):
        x = X[i]

        # Forward pass
        hidden_state = sigmoid(x * Wxh + hidden_state * Whh)
        output = sigmoid(hidden_state * Why)

        # Error
        error = y[i] - output

        # Weight updates
        Why += lr * hidden_state * error
        Wxh += lr * x * error
        Whh += lr * hidden_state * error

    # âœ… Print loss every 500 epochs
    if epoch % 500 == 0:
        print("Epoch:", epoch, "Loss:", np.mean(np.abs(error)))
Epoch: 0 Loss: 0.3604287729817308
Epoch: 500 Loss: 0.3604287729817348
Epoch: 1000 Loss: 0.3604287729817348
Epoch: 1500 Loss: 0.3604287729817348
Epoch: 2000 Loss: 0.3604287729817348
Epoch: 2500 Loss: 0.3604287729817348
print("\nPredictions after training:")
hidden_state = 0
for i in range(len(X)):
    x = X[i]
    hidden_state = sigmoid(x * Wxh + hidden_state * Whh)
    output = sigmoid(hidden_state * Why)
    print("Input:", i, "Predicted:", round(output.item() * np.max(y), 2))
Predictions after training:
Input: 0 Predicted: 0.58
Input: 1 Predicted: 0.65
Input: 2 Predicted: 0.65
Input: 3 Predicted: 0.65
Input: 4 Predicted: 0.65
 
